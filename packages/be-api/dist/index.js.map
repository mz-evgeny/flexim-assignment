{"version":3,"sources":["../src/utils/db.ts","../src/schemas/supplier.ts","../src/models/supplier.ts","../src/schemas/product.ts","../src/models/product.ts","../src/storage/products.ts","../src/storage/suppliers.ts","../src/index.ts"],"names":["connect","mongoose","disconnect","SupplierSchema","Schema","Supplier","model","ProductSchema","Product","getPaginatedProducts","page","limit","sortField","sortOrder","searchTerm","skip","match","sortOptions","result","total","getSuppliers","app","express","port","req","res","closeApp"],"mappings":"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","file":"index.js","sourcesContent":["import mongoose from \"mongoose\";\n\nexport const connect = async (): Promise<void> => {\n  await mongoose.connect(\n    process.env.MONGO_URI || \"mongodb://127.0.0.1:27017/flexim\"\n  );\n};\n\nexport const disconnect = async (): Promise<void> => {\n  await mongoose.disconnect();\n};\n","import { Schema } from \"mongoose\";\nimport { Supplier } from \"src/interfaces/supplier\";\n\nexport const SupplierSchema = new Schema<Supplier>({\n  name: { type: String, required: true },\n  country: { type: String, required: true },\n});\n","import { model } from \"mongoose\";\nimport { SupplierSchema } from \"src/schemas/supplier\";\n\nexport const Supplier = model(\"Supplier\", SupplierSchema);\n","import { Schema } from \"mongoose\";\nimport { Product } from \"src/interfaces/product\";\nimport { Supplier } from \"src/models/supplier\";\n\nexport const ProductSchema = new Schema<Product>({\n  sku: { type: String, required: true, unique: true },\n  name: { type: String, required: true },\n  description: { type: String, required: true },\n  supplierId: { type: Schema.Types.ObjectId, ref: Supplier, required: true },\n  manufacturingDate: { type: Date, required: true },\n});\n","import { model } from \"mongoose\";\nimport { ProductSchema } from \"src/schemas/product\";\n\nexport const Product = model(\"Product\", ProductSchema);\n","import { Product } from \"src/models/product\";\nimport { Product as IProduct } from \"src/interfaces/product\";\n\ninterface Params {\n  page?: number;\n  limit?: number;\n  sortField?: string;\n  sortOrder?: \"asc\" | \"desc\";\n  searchTerm?: string;\n}\n\ninterface Result {\n  data: IProduct[];\n  total: number;\n  page: number;\n  totalPages: number;\n}\n\nexport async function getPaginatedProducts({\n  page = 1,\n  limit = 50,\n  sortField = \"sku\",\n  sortOrder = \"asc\",\n  searchTerm = \"\",\n}: Params): Promise<Result> {\n  const skip = (page - 1) * limit;\n\n  const match: any = {};\n  if (searchTerm) {\n    match.$or = [\n      { sku: { $regex: searchTerm, $options: \"i\" } },\n      { name: { $regex: searchTerm, $options: \"i\" } },\n    ];\n  }\n\n  const sortOptions: any = {};\n  if (sortField === \"supplier\") {\n    sortOptions[\"supplier.name\"] = sortOrder === \"asc\" ? 1 : -1;\n  } else {\n    sortOptions[sortField] = sortOrder === \"asc\" ? 1 : -1;\n  }\n\n  const [result] = await Product.aggregate([\n    { $match: match },\n    {\n      $lookup: {\n        from: \"suppliers\",\n        localField: \"supplierId\",\n        foreignField: \"_id\",\n        as: \"supplier\",\n      },\n    },\n    { $unwind: \"$supplier\" },\n    {\n      $facet: {\n        data: [\n          { $sort: sortOptions },\n          { $skip: skip },\n          { $limit: limit },\n          {\n            $project: {\n              _id: 1,\n              sku: 1,\n              name: 1,\n              description: 1,\n              supplierId: \"$supplier._id\",\n              manufacturingDate: 1,\n            },\n          },\n        ],\n        total: [{ $group: { _id: null, count: { $sum: 1 } } }],\n      },\n    },\n  ]);\n\n  const total = result.total[0]?.count || 0;\n\n  return {\n    data: result.data,\n    total,\n    page,\n    totalPages: Math.ceil(total / limit),\n  };\n}\n","import { Supplier as ISupplier } from \"src/interfaces/supplier\";\nimport { Supplier } from \"src/models/supplier\";\n\nexport const getSuppliers = async (): Promise<ISupplier[]> => {\n  const result = await Supplier.find().lean();\n\n  return result;\n};\n","import express from \"express\";\nimport { connect, disconnect } from \"src/utils/db\";\nimport { getPaginatedProducts } from \"./storage/products\";\nimport { getSuppliers } from \"./storage/suppliers\";\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/products\", async (req, res) => {\n  const result = await getPaginatedProducts(req.query);\n\n  res.send(result);\n});\n\napp.get(\"/suppliers\", async (req, res) => {\n  const result = await getSuppliers();\n\n  res.send(result);\n});\n\napp.listen(port, async () => {\n  await connect();\n  console.info(`ðŸš€ Server ready at port : ${port}`);\n});\n\nconst closeApp = async () => {\n  await disconnect();\n  console.info(\"ðŸ›‘ Database connection closed.\");\n  process.exit(0);\n};\n\nprocess.on(\"SIGINT\", closeApp);\nprocess.on(\"SIGTERM\", closeApp);\n"]}